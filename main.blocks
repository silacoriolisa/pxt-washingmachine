<xml xmlns="https://developers.google.com/blockly/xml"><variables></variables><block type="pxt-on-start" id="hTZ-CQY/b6/{{OHhjI*O" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id=",WJvIF3op%Nv}EW2^=aQ"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace WashingMachine {" line1="" line2="    /**" line3="     * *****************************************************************************************************************************************" line4="     * This extension provides the control block for a custom made washing machine toy. The toy has been reworked so that it is entirely controlled" line5="     * by BBC:microbit. This extension operates on Programs and Patterns. " line6="     * " line7="     * Each Program should be defined within a separate function in the main project." line8="     * Each Program can consist of forward (CW) and backward (CCW) movement phases with braking in between if spinning direction has changed." line9="     * Including braking is a User responsibility." line10="     * " line11="     * A special spinning Patterns like pulse and pyramid staris/patterns are provided as blocks for auto execution - no need to define a function. " line12="     * Each spinning Pattern (similarly to Programs) auto updates the timer and reacts to stopButton." line13="     * Aborting the program will abort the countdown timer and clear the display. At the moment a User can only abort a single phase of Program/Pattern." line14="     * " line15="     * Exposed blocks:" line16="     * readButton(button: buttonsNames): number" line17="     * SpinMe(direction: dirOpt, speed: number, spinTime: number, stopCmd?: brakeOpt): void" line18="     * createPattern(mode: modOpt, noSteps: number, stepTime: number, direction?: dirOpt, speedA?: number, speedB?: number): SpinPattern" line19="     * executePattern(): void" line20="     * *****************************************************************************************************************************************" line21="     * Left to do:" line22="     * (1) Use doxygen style comments - explore github actions and doxygen generation" line23="     * (OK) Dependencies: DF-Driver added to dependencies in 'Project Settings'" line24="     * () Explore control lib: background tasks scheduling and events" line25="     * () At the moment all functions/APIs are blocking - can be rewritten to return a state variable that will allow User to add extra code after calling APIs" line26="     * () Callbacks?" line27="     * () Explore shadowing" line28="     * () Explore static variables" line29="     * () Pyramid peak has double the segment time" line30="     * () Add slider where speeds are selected" line31="     * (4) Should Patterns be coded as classes? Can functions do the same? Any benefits from classes here? Try to refactor to take advantage of OOP" line32="     * check this thread https://stackoverflow.com/questions/6480676/why-use-classes-instead-of-functions" line33="     * () doorButton may have reversed logic, what would require a unification in readButton" line34="     * () Add pause/resume button - this one should use events" line35="     * () Buttons mappings to be checked" line36="     * () Convert old WM project to use this extension" line37="     * (3) Add abort function e.x. by long-press of stopButton - to stop complex sequences" line38="     * (OK) Bit sizes (int8, int16 ..) are not supported inside class methods. No other restrictions are known." line39="     * " line40="     */" line41="" line42="    /**" line43="     * *****************************************************************************************************************************************" line44="     * Global variables section" line45="     */" line46="" line47="    let lastDigit: number = 0; //This variable is used to store last display value of countdown timer to prevent too quick display refreshing" line48="" line49="    /**" line50="     * *****************************************************************************************************************************************" line51="     * Enums section" line52="     */" line53="" line54="    //This enum lists names of supported buttons" line55="    export enum buttonsNames {" line56="        //%block=&quot;Start&quot;" line57="        startButton," line58="        //%block=&quot;Stop&quot;" line59="        stopButton," line60="        //%block=&quot;Pause/Resume&quot;" line61="        pauseButton," line62="        //%block=&quot;Doors&quot;" line63="        doorButton" line64="    }" line65="" line66="    //This enum lists braking options" line67="    export enum brakeOpt {" line68="        //%block=&quot;brake&quot;" line69="        brake," line70="        //%block=&quot;don't brake&quot;" line71="        nobrake" line72="    }" line73="" line74="    //This enum lists the washing machine spinning direction" line75="    export enum dirOpt {" line76="        //%block=&quot;clockwise&quot;" line77="        clockwise," line78="        //%block=&quot;counter clockwise&quot;" line79="        cclockwise" line80="    }" line81="" line82="    //This enum lists Pattern execution options" line83="    export enum modOpt {" line84="        //%block=&quot;pulse&quot;" line85="        pulse," line86="        //%block=&quot;steps&quot;" line87="        steps," line88="        //%block=&quot;pyramid&quot;" line89="        pyramid" line90="    }" line91="" line92="    /**" line93="     * *****************************************************************************************************************************************" line94="     * Functions section" line95="     */" line96="" line97="    /**" line98="     * @function    readButton  Returns selected button state through digital pin reading." line99="     * @param       button      Name of the button" line100="     * @returns                 State of the button which corresponds to its logical state i.e. 1 or 0" line101="     */" line102="    //%block = &quot;Check the %button button&quot;" line103="    export function readButton(button: buttonsNames): number {" line104="        let buttonCode: number;" line105="" line106="        switch (button) {" line107="            case buttonsNames.startButton:" line108="                buttonCode = 12;" line109="                break;" line110="            case buttonsNames.stopButton:" line111="                buttonCode = 13;" line112="                break;" line113="            case buttonsNames.doorButton:" line114="                buttonCode = 16;" line115="                break;" line116="" line117="        }" line118="" line119="        return pins.digitalReadPin(buttonCode);" line120="    }" line121="" line122="    /**" line123="     * @function    SpinMe      Spins the motor in selected direction with given speed and for given time; " line124="     *                          After the time has elapsed motor stops with or without braking phase." line125="     * @param       direction   Clockwise or counterclockwise selector" line126="     * @param       speed       Value of speed &lt;0, 255&gt;" line127="     * @param       spinTime    Value in [s]" line128="     * @param       stopCmd     Brake or nobrake selector. This parameter is optional with default value = brake (in case not given explicitly)" line129="     */" line130="    //% block=&quot;Spin %direction with speed %speed for %spintime seconds.|| At the end: %stopCmd&quot;" line131="    //% inlineInputMode=inline" line132="    //% stopCmd.defl=brakeOpt.brake" line133="    //% speed.min=0 speed.max=255" line134="    export function SpinMe(direction: dirOpt, speed: number, spinTime: number, stopCmd?: brakeOpt): void {" line135="" line136="        runMotor(direction, speed);" line137="        let startTstamp = control.millis();" line138="        while (monitorUserStop() &amp;&amp; runCountdown(startTstamp, spinTime));" line139="" line140="        motor.motorStop(motor.Motors.M1);" line141="        if (stopCmd == brakeOpt.brake) {" line142="            basic.pause(1800); //An arbitrary time interval to fully stop the motor." line143="        }" line144="        basic.clearScreen();" line145="        basic.pause(200); //Check if needed" line146="    }" line147="" line148="    /**" line149="     * @function    runMotor    Start a motor in specified direction and speed" line150="     * @param       direction   Either CW or CCW" line151="     * @param       speed       Speed as a number in &lt;0, 255&gt; range" line152="     */" line153="    function runMotor(direction: dirOpt, speed: number): void {" line154="        switch (direction) {" line155="            case dirOpt.clockwise:" line156="                motor.MotorRun(motor.Motors.M1, motor.Dir.CW, speed);" line157="            case dirOpt.cclockwise:" line158="                motor.MotorRun(motor.Motors.M1, motor.Dir.CCW, speed);" line159="                break;" line160="        }" line161="    }" line162="" line163="    /**" line164="     * @function    runCountdown    Function counts the ms elapsed since the start_tstamp, compares it with time and update the display." line165="     *                              Display is only updated on the counter change (in seconds)" line166="     * @param       start_tstamp    The moment in time [ms] with respect to which the counter is downcounting" line167="     * @param       time            The amount of time [s] for downcounting" line168="     */" line169="    function runCountdown(start_tstamp: number, time: number): boolean {" line170="" line171="        let timeLeft: number;" line172="        time *= 1000;" line173="" line174="        if (lastDigit == 0)" line175="            lastDigit = time;" line176="" line177="        let current_tstamp = control.millis();" line178="        timeLeft = Math.trunc((time - (current_tstamp - start_tstamp)) / 1000);" line179="        if (timeLeft != lastDigit)" line180="            basic.showNumber(timeLeft);" line181="" line182="        if (timeLeft &gt; 0) {" line183="            lastDigit = timeLeft;" line184="            return true;" line185="        }" line186="        else {" line187="            lastDigit = 0;" line188="            return false;" line189="        }" line190="    }" line191="" line192="    /**" line193="     * @function    monitorUserStop Function that returns the boolean that corresponds to logical state of stopButton" line194="     */" line195="    function monitorUserStop(): boolean {" line196="        if (readButton(buttonsNames.stopButton))" line197="            return false;" line198="        else" line199="            return true;" line200="    }" line201="" line202="    /**" line203="     * *****************************************************************************************************************************************" line204="     * Classes section" line205="     */" line206="    export class SpinPattern {" line207="        " line208="        mode: modOpt;" line209="        noSteps: number;" line210="        stepTime: number;" line211="        direction: dirOpt;" line212="        speedA: number;" line213="        speedB: number;" line214="        " line215="        constructor(mode: modOpt, noSteps: number, stepTime: number, direction: dirOpt, speedA: number, speedB: number){" line216="" line217="            this.mode = mode;" line218="            this.noSteps = noSteps;" line219="            this.stepTime = stepTime;" line220="            this.direction = direction;" line221="            this.speedA = speedA;" line222="            this.speedB = speedB;" line223="        }" line224="" line225="        /**" line226="         * @function    executePattern  This function execute created Pattern, at the moment three pre-defined patterns are available:" line227="         *                              Pulse, Step and Pyramid." line228="         */" line229="        //%block=&quot;Execute %myPattern program&quot;" line230="        public executePattern(): void {" line231="            " line232="            switch(this.mode){" line233="                case modOpt.pulse:" line234="                break;" line235="                case modOpt.steps:" line236="                    this.executeSteps();" line237="                break;" line238="                case modOpt.pyramid:" line239="                break;" line240="            }" line241="" line242="            motor.motorStop(motor.Motors.M1);" line243="            basic.clearScreen();" line244="" line245="        }" line246="" line247="        executePyramid(){" line248="            this.executeSteps();" line249="            this.switchSpeeds();" line250="            this.executeSteps(); //the flaw of this simple apporach is that at peak of the pyramid segment time is doubled" line251="            this.switchSpeeds();" line252="" line253="        }" line254="" line255="        executePulse(){" line256="            for (let i = this.noSteps; i&gt;0; i--) {" line257="                runMotor(this.direction, this.speedA);" line258="                this.completeSegment();" line259="                runMotor(this.direction, this.speedB);" line260="                this.completeSegment();" line261="            }" line262="        }" line263="" line264="        executeSteps(){" line265="            " line266="            let speed: number;" line267="            let deltaSpeed: number = (this.speedB - this.speedA) / this.noSteps; //!&lt; deltaSpeed can be positive and negative" line268="" line269="            for (let j = this.noSteps; j &gt; 0; j--) {" line270="                speed = (this.noSteps - j) * deltaSpeed + this.speedA;" line271="                runMotor(this.direction, speed);" line272="                this.completeSegment();" line273="            }" line274="            " line275="        }" line276="" line277="        completeSegment(): void {" line278="            let startTstamp2 = control.millis();" line279="            while (monitorUserStop() &amp;&amp; runCountdown(startTstamp2, this.stepTime));" line280="        }" line281="" line282="        switchSpeeds(): void {" line283="            let temp = this.speedA;" line284="            this.speedA = this.speedB;" line285="            this.speedB = temp;" line286="        }" line287="" line288="    }" line289="" line290="    /**" line291="     * Factory function exposing User Pattern constructor " line292="     */" line293="    //% block=&quot;%mode pattern with %noSteps segments,  each segment %stepTime [s] long. || Spin %direction with speeds between %speedA and %speedB&quot;" line294="    //% direction.defl = dirOpt.clockwise" line295="    //% speedA.defl = 0" line296="    //% speedB.defl = 255" line297="    //% speedA.min=0 speedA.max=255" line298="    //% speedB.min=0 speedB.max=255" line299="    //% blockSetVariable=myPattern" line300="    //% inlineInputMode=inline" line301="    export function createPattern(mode: modOpt, noSteps: number, stepTime: number, direction?: dirOpt, speedA?: number, speedB?: number): SpinPattern {" line302="    " line303="        return new SpinPattern(mode, noSteps, stepTime, direction, speedA, speedB);" line304="" line305="    }" line306="" line307="}" numlines="308"></mutation></block></statement></block></xml>